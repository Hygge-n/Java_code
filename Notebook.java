//***************java命名规范********************************
/*
*   包名:多个单词组成时所有字母都小写
*   类名，接口名:多个单词组成时，所有字母的首字母都大写
*   变量名，方法名:多单词组成时，第一个字母小写，从第二个单词后首字母大写
*   常量名:所有字母都大写，多单词是每个字母用下滑线组成
* char类型的默认值为空
*/
//******************运算符***********************************
/*
*运算符: 1.算术运算符:+，-，*，/，%，++(前加加：先增一后运算，后加加：先运算后加一；自增不会改变数据类型)，--
*       2.赋值运算符:=,+=,-=,/=,*=,%=
*       3.比较运算符:>,<,==,>=,<=,!=
*       4.逻辑运算符:&(逻辑与),|(逻辑或),!(逻辑非),&&(短路与),||(短路或),^(逻辑异或)
*       5.位运算符
*       6.三元运算符
*/
//*******************数组************************************
/*
*数组：引用数据类型
*     多个相同类型的数据，按照一定顺序排列的集合，并使用一个名字命名，通过编号的方法对数据进行统一管理
*     < 数组名:
*     < 元素:既可以是基本数据类型，也可以是引用数据类型
*     < 特点:有序排列，长度不可更改,会开辟一整块连续的空间
*   （二维数组）：方法一：int[][] arr=new int[3][4];
*                   外层元素的初始值为：地址值
*                   内层元素的初始值为：元素类型默认值
*              方法二：int[][] arr=new int[3][]
*                   外层元素的初始值为：元素类型默认值
*                   内层元素的初始值为：不能调用，否则报错
*/
//******************数据结构**********************************
/*
*数据结构：
*   1.数据与数据之间的逻辑关系：集合，一对多，一对一，多对多
*   2.数据的存储结构：
*       线性表：顺序表（数组），链表，栈，队列
*       树形结构：二叉树
*       图形结构
*/
//******************面向对象**********************************
//面向对象与面向过程
/*
* 面向过程：强调的是功能行为，以函数为最小对象，考虑怎么做
* 面向对象：强调具备功能的对象，以类或对象为最小单位，考虑谁来做
*/
//面向对象的两个要素：类和对象
/*
*类：对一类事物的描述，是抽象，概念上的定义
*对象：是实际存在的该类事物的某个个体
*   对象是类的实例化
* 类：设计类，就是设计类的属性
*       属性=成员变量=field=域，字段
*       方法=成员方法=函数=methon
*/
//方法形参的值传递机制
/*
*基本数据类型：数据值
*引用数据类型：地址值
*/
//封装性
/*
*权限修饰符：public   protected  缺省  private  （1可以访问，0不可以访问）
*    类内部     1         1       1       1
*    同一个包    1         1       1       0
*   不同包子类    1         1       0       0
*     任意位置    1         0       0       0
* 构造器（构造方法）：（作用）创造对象    权限修饰符 类名（形参列表）{}
*               一个类中至少会有一个构造器
*/
//继承性
/*
*面向对象的特征之二：继承性
*   继承性：（好处）1.提高代码的复用性
*                2.便于功能的拓展
*                3.为之后的多态性提供了前提
*          （格式）class A extends B{}
*                A:子类，派生类,subclass
*                B:父类，超类，基类，superclass
*         一旦子类继承父类，子类就获取了父类中声明的结构，属性，方法
*          （规定）一个父类可以有多个子类，子类的功能更强大
*                子类父类是相对的概念；可以多层继承
*/
//多态性(运行时行为)
/*
*对象的多态性：一种事物的多种形态
* 父类的引用指向子类的对象(父类的方法称为虚拟方法)
*   当调用子父类同名同参的方法时，实际执行的是子类重写父类的方法————————虚拟方法调用
* 多态性：（编译期）只能调用父类声明的方法
*       （运行期）执行的是子类重写父类的方法
* 适用前提：类继承关系，方法的重写
*         多态性只适用于方法，不适用于属性（编译和运行只看左边）
* 向下改型：使用强制类型转化符（调用子类特有的属性和方法）
*/
//方法的重写
/*
*重写：在子类继承父类后，可以对父类同名同参的类进行覆盖
*     重写以后，当创建子类对象以后，通过子类对象调用子父类同名同参的方法时，实际上被操作的是重写以后的方法
*       子类中叫重写的方法，父类中叫做被重写的方法
*       子类中重写的方法的权限修饰符不小于父类中的权限修饰符
*       >子类中不能重写父类中private权限的方法
*       >父类的返回值类型是void，子类中也要是void
*       >父类的返回值类型是基本数据类型，子类中的数据类型也要一样
* 若子类重写了父类的方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统不可能把父类中的方法转移到子类中
* 对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量仍不可完全覆盖父类中的实例变量
*                   （编译看左边，运行看右边）
*/
/*
* 重载：允许多个同名的方法，而这些方法的参数不同，编译器会根据方法不同的参数表，对同名的方法名称进行修饰
*       （他们的调用在编译时期就被确定了，早调用）
* 多态：只有等到方法调用的那一刻起，解释运行器才会确定所要调用的方法，（晚绑定）
*/
//****************关键字**********************
/*
*this调用构造器：在类的构造器中，可以显示的使用“this(形参列表)”调用本类的其它构造器；
*             构造器不能通过this调用自己，会形成死循环；
*             如果一个类中有n个构造器，那么可以调用n-1次this；
*             this调用必须在本构造器的首行；
*             构造器内部最多只能声明一个this来调用其它构造器；
* package:  为了更好的实现项目中的管理
*           使用package声明的接口或者包，声明在第一行
*           包，属于标识符，遵循标识符的命名规范
*           每’.‘一次就代表一层文件目录
*       同一个包下，不能命名同名的接口，类
*       不同的包下，可以命名同名的接口，类
* import: 在原文件中显示的使用import结构导入指定包下的类，接口
*         声明在包的声明和类的声明之间
*         如果需要导入多个结构，并列写出即可
*         可以使用’.*‘的方式，导入本包的所有结构
* super:在子类中调用与父类重名的属性时，必须用"super.属性"显示的调用父类中重写的方式
* instanceof:   a instanceof A:判断a是否是类A的实例，如果是，返回true,如果不是,返回false
*            为了避免在向下转型时出现异常，在转型之前，先进行instanceof判断，一旦true就向下转型
*/
/*
* ==和equals的区别：
*   ==：
*       可以使用在基本数据类型中，也可以使用在引用数据类型中
*       在基本数据类型中，比较的是两个变量的数据值（不一定要类型相同）
*       在引用数据类型中，比较的是两个引用数据类型的地址值，即两个引用是否指向同一个对象实例
*   equals:
*       只是一个方法，并不是标识符
*       只能适用于引用数据类型
*       Object类中equals()的定义：
*           public boolean class(Object obj){
*               return (this==obj);
*       }
* Object类中equals（）和==的作用是相同的，比较两个地址值是否相等
* 像String,Data,File，包装类都重写了Object中的equals（）方法，重写以后，比较的是两个对象的“实体内容”是否相同
* equals:
*   对称性：如果x.equals(y)返回的“true”,那么y.equals(x)也应该返回的是“true”
*   自反省：x.equals(x)必须返回的是true
*   传递性：如果想x.equals(y)返回的是“true”,而且y.equals(z)返回的是“true”,那么z.equals(x)也应该返回"true"
*   一致性：如果x.equals(y)返回的是"true",而只要x和y的值一直不变，不管重复多少次x.equals(y),返回值总是"true"
*   任何情况下，x.equals(null),永远返回“false”;
*   x.equals(和x不同类型的对象)返回永远是"false";
*/
//包装类
/*
* Byte,Short,Integer,Long,Float,Double,Boolean,Character
* 提供了八种基本数据类型对应的包装类，使得基本数据类型具有类的特征
* 基本数据类型——————>包装类：使用包装类的构造器
* 包装类——————>基本数据类型：调用包装类的xxxValue()
*/
//**********************static**************************
/*
* static:静态的
*        用来修饰：方法，属性，代码块，内部类
* static修饰属性：静态变量
*        实例变量：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性，
*                当修改其中的一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改
*        静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时
*                会导致其他对象调用此静态变量时，是修改过了的
*    静态变量是跟着类的加载而加载。可以通过“类，静态变量”的方式进行调用
*    静态变量的加载要早于对象的创建。
*    由于类只加载一次，则静态变量在内存中也会存在一份，存在方法区的静态域中
* 单例设计模式：采取一定方法保证在整个的软件系统中，对某个类只能存在一个对象实例
*            只生成一个实例，减少了系统的开销，当一个对象的产生需要比较多的资源，如读取
*            配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后
*            永久驻留内存的方式解决
*   ********************* 饿汉式 vs 懒汉式 ************************
*   饿汉式：（坏处）对象加载时间过长
*         （好处）线程安全
*   懒汉式：（坏处）延迟对象的创建
*         （好处）线程不安全
*/
//************************main**************************
/*
* main(): 程序的入口,一个普通的静态方法
*         也可以作为控制台进行交互
*/
//*******************类的成员之四：代码块******************
/*
* 代码块：用来初始化类或者对象，只能用static修饰，不能用其他修饰
* 分类：静态代码块 VS 非静态代码块
*   静态代码块:
*       >内部可以有输出语句
*       >随着类的加载而执行
*       >初始化类的信息
*   非静态代码块:
*       >内部可以有输出语句
*       >随着对象的创建而执行
*/
//抽象类与抽象方法
/*
* abstract:可以用来修饰结构、类（抽象类）、方法（抽象方法）
*         一旦抽象了，就不可实例化
*         抽象类一定有构造器，便于子类实例化时调用
* 抽象方法：
*       >抽象方法只有方法的声明，没有方法体
*       >包含抽象方法的类，一定是一个抽象类.抽象类中可以没有抽象方法
*       >若子类重写了父类的抽象方法，则子类可实例化
*           若子类没有重写父类中所有的抽象方法，则子类也是一个抽象类，需要用abstract修饰
* abstract不能用来修饰，属性、构造器等结构
*         不能用来修饰私有方法，静态方法、final的方法、final的类
*/
//接口
/*
* 接口：接口和类是并列的两个结构
*      >全局常量：public static final（书写时可以省略不写）
*      >抽象方法：public abstract
* 接口中不能定义构造器，接口不能实例化
* 如果实现类覆盖了接口中的所有方法，
*/















